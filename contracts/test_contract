// SPDX-License-Identifier: SEE LICENSE IN LICENSE
// pragma solidity 0.8.20;

// import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.solhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol";


// pragma solidity ^0.8.0;

// contract ItemMarketplace {
//     address public owner;

//     struct Item {
//         uint itemId;
//         address owner;
//         string itemName;
//         uint price;
//         bool forSale;
//     }

//     mapping(uint => Item) public items;
//     uint public itemCount;

//     event ItemAdded(uint itemId, string itemName, uint price, address owner);
//     event ItemSold(uint itemId, address newOwner);

//     constructor() {
//         owner = msg.sender;
//     }

//     modifier onlyOwner() {
//         require(msg.sender == owner, "Only the owner can perform this operation");
//         _;
//     }

//     function addItem(string memory _itemName, uint _price) public onlyOwner {
//         itemCount++;
//         items[itemCount] = Item(itemCount, owner, _itemName, _price, true);
//         emit ItemAdded(itemCount, _itemName, _price, owner);
//     }

//     function buyItem(uint _itemId) public payable {
//         require(_itemId <= itemCount && _itemId > 0, "Invalid item ID");
//         Item storage item = items[_itemId];
//         require(item.forSale, "Item is not for sale");
//         require(msg.value >= item.price, "Insufficient funds sent");

//         address previousOwner = item.owner;
//         item.owner = msg.sender;
//         item.forSale = false;

//         // Transfer funds to the previous owner
//         payable(previousOwner).transfer(msg.value);

//         emit ItemSold(_itemId, msg.sender);
//     }

//     function transferOwnership(address newOwner) public onlyOwner {
//         owner = newOwner;
//     }
// }
